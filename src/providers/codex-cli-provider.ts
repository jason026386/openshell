import type { ConversationMessage } from "../types.js";
import type {
  ProviderStreamCallbacks,
  ProviderStreamOptions,
} from "./provider-registry.js";
import { renderCliPrompt } from "./render-cli-prompt.js";
import { runJsonlCli } from "./run-jsonl-cli.js";

interface CodexItem {
  type?: string;
  text?: string;
  command?: string;
  status?: string;
}

interface CodexEvent {
  type?: string;
  item?: CodexItem;
  delta?: string;
  output_text?: string;
  message?: string;
  error?: {
    message?: string;
  };
}

function extractCodexErrorMessage(raw: string | undefined): string {
  const trimmed = raw?.trim();
  if (!trimmed) {
    return "";
  }

  try {
    const parsed = JSON.parse(trimmed) as { detail?: string; message?: string };
    if (parsed.detail?.trim()) {
      return parsed.detail.trim();
    }
    if (parsed.message?.trim()) {
      return parsed.message.trim();
    }
  } catch {
    // Use raw string as-is when not JSON.
  }

  return trimmed;
}

function extractUsefulStderr(stderrTail: string): string {
  const noisyPattern = "rollout::list: state db missing rollout path for thread";
  const lines = stderrTail
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => line.length > 0 && !line.includes(noisyPattern));
  return lines[lines.length - 1] ?? "";
}

export class CodexCliProvider {
  public constructor(
    private readonly command: string,
    private readonly cwd: string,
    private readonly model?: string,
    private readonly dangerouslyBypassApprovalsAndSandbox = false,
  ) {}

  public async stream(
    messages: ConversationMessage[],
    callbacks: ProviderStreamCallbacks,
    options?: ProviderStreamOptions,
  ): Promise<string> {
    let reply = "";
    let cliErrorMessage = "";
    const args = ["exec", "--json", "--skip-git-repo-check"];
    const model = options?.model?.trim() || this.model;
    const reasoningEffort = options?.reasoningEffort?.trim().toLowerCase();
    if (this.dangerouslyBypassApprovalsAndSandbox) {
      args.push("--dangerously-bypass-approvals-and-sandbox");
    }
    if (model) {
      args.push("--model", model);
    }
    if (reasoningEffort) {
      args.push("-c", `model_reasoning_effort="${reasoningEffort}"`);
    }
    args.push("-");

    const result = await runJsonlCli(
      this.command,
      args,
      this.cwd,
      renderCliPrompt(messages),
      {
        onLine: async (line) => {
          let event: CodexEvent;
          try {
            event = JSON.parse(line) as CodexEvent;
          } catch {
            return;
          }

          if (event.type === "item.started") {
            const item = event.item;
            if (item?.type === "command_execution" && item.command) {
              await callbacks.onStatus?.(`실행 중: ${item.command}`);
            }
            return;
          }

          if (event.type === "error") {
            const errorMessage = extractCodexErrorMessage(event.message);
            if (errorMessage) {
              cliErrorMessage = errorMessage;
            }
            return;
          }

          if (event.type === "turn.failed") {
            const errorMessage = extractCodexErrorMessage(event.error?.message);
            if (errorMessage) {
              cliErrorMessage = errorMessage;
            }
            return;
          }

          if (
            (event.type === "item.completed" || event.type === "item.updated") &&
            event.item?.type === "agent_message" &&
            typeof event.item.text === "string"
          ) {
            reply = event.item.text;
            await callbacks.onText(reply);
            return;
          }

          if (event.type === "response.output_text.delta" && event.delta) {
            reply += event.delta;
            await callbacks.onText(reply);
            return;
          }

          if (event.type === "response.completed" && typeof event.output_text === "string") {
            reply = event.output_text;
            await callbacks.onText(reply);
          }
        },
      },
    );

    const finalReply = reply.trim();

    if (result.code !== 0) {
      if (finalReply && !cliErrorMessage) {
        // Some codex versions emit non-fatal exit codes after producing a complete message.
        console.warn(
          `[openshell] codex exited with code ${result.code} but returned text. Returning the generated reply.`,
        );
        return finalReply;
      }

      const structuredError = cliErrorMessage.trim();
      const stderrMessage = extractUsefulStderr(result.stderrTail);
      const detail = structuredError || stderrMessage;
      throw new Error(
        `codex CLI exited with code ${result.code}${detail ? `: ${detail}` : ""}`,
      );
    }

    if (!finalReply) {
      throw new Error("codex CLI 응답이 비어 있습니다.");
    }

    return finalReply;
  }
}
