import { Telegraf } from "telegraf";

import type { ChatService } from "../chat/chat-service.js";
import {
  buildModelListMessage,
  CODEX_REASONING_EFFORT_LEVELS,
  ModelCatalogService,
  type RuntimeProviderInfo,
} from "./model-list.js";
import { createStreamEditController, truncateForPlatform } from "./stream-edit.js";
import { splitTextForPlatform } from "./text-chunk.js";
import { TelegramOwnerStore } from "./telegram-owner-store.js";

const HELP = [
  "OpenShell (Telegram)",
  "/init                    - 1회 초기화 (소유자 등록)",
  "/model codex|claude       - provider 전환",
  "/model [provider] <model|default> [effort|default] - 모델 변경",
  "/models                  - 지원 모델 목록 (매번 새로 조회)",
  "/reset                   - 현재 대화 기록 초기화",
  "/uid                     - 현재 사용자 UID 확인",
  "/help                    - 도움말",
].join("\n");

const DANGER_WARNING = [
  "주의: OpenShell은 codex/claude CLI를 승인/샌드박스 없이 실행하도록 구성되어 있습니다.",
  "악성 프롬프트는 로컬 파일 읽기/수정, 명령 실행 등 PC에 피해를 줄 수 있습니다.",
  "봇 토큰을 공유하지 말고, /init으로 소유자(1인) 잠금을 완료한 뒤 사용하세요.",
].join("\n");

const RESET_KEYWORDS = new Set(["default", "reset", "none"]);
const CODEX_REASONING_EFFORT_SET = new Set<string>(CODEX_REASONING_EFFORT_LEVELS);

function isResetKeyword(value: string | undefined): boolean {
  return Boolean(value && RESET_KEYWORDS.has(value.toLowerCase()));
}

function escapeTelegramMarkdownV2(text: string): string {
  return text.replace(/([_*\[\]()~`>#+\-=|{}.!\\])/g, "\\$1");
}

function escapeTelegramInlineCode(text: string): string {
  return text.replace(/([`\\])/g, "\\$1");
}

function escapeTelegramCodeBlock(text: string): string {
  return text.replace(/\\/g, "\\\\").replace(/```/g, "\\`\\`\\`");
}

function formatTelegramRichText(text: string): string {
  const codeBlocks: string[] = [];
  let working = text.replace(/```(?:[^\n`]*)\n([\s\S]*?)```/g, (_match, code) => {
    const token = `OSCODEBLOCK${codeBlocks.length}TOKEN`;
    codeBlocks.push(code ?? "");
    return token;
  });

  const inlineCodes: string[] = [];
  working = working.replace(/`([^`\n]+?)`/g, (_match, code) => {
    const token = `OSINLINECODE${inlineCodes.length}TOKEN`;
    inlineCodes.push(code ?? "");
    return token;
  });

  const bolds: string[] = [];
  working = working.replace(/\*\*([\s\S]+?)\*\*/g, (_match, value) => {
    const token = `OSBOLD${bolds.length}TOKEN`;
    bolds.push(value ?? "");
    return token;
  });

  let formatted = escapeTelegramMarkdownV2(working);

  formatted = formatted.replace(/OSBOLD(\d+)TOKEN/g, (_match, index) => {
    const boldText = bolds[Number(index)] ?? "";
    return `*${escapeTelegramMarkdownV2(boldText)}*`;
  });

  formatted = formatted.replace(/OSINLINECODE(\d+)TOKEN/g, (_match, index) => {
    const code = inlineCodes[Number(index)] ?? "";
    return `\`${escapeTelegramInlineCode(code)}\``;
  });

  formatted = formatted.replace(/OSCODEBLOCK(\d+)TOKEN/g, (_match, index) => {
    const code = codeBlocks[Number(index)] ?? "";
    return `\`\`\`\n${escapeTelegramCodeBlock(code)}\n\`\`\``;
  });

  return formatted;
}

function chatKeyFromContext(ctx: { chat?: { id: number } }): string {
  return `telegram:${ctx.chat?.id ?? "unknown"}`;
}

interface TelegramReplyMessageLike {
  text?: string;
  caption?: string;
  from?: {
    id?: number;
    username?: string;
    first_name?: string;
    last_name?: string;
  };
}

function buildTelegramPromptWithReplyContext(
  text: string,
  replyMessage: unknown,
): string {
  const reply = replyMessage as TelegramReplyMessageLike | undefined;
  if (!reply) {
    return text;
  }

  const replyText = (reply.text ?? reply.caption ?? "").trim();
  if (!replyText) {
    return text;
  }

  const from = reply.from;
  let sender = "unknown";
  if (from?.username) {
    sender = `@${from.username}`;
  } else if (from?.first_name || from?.last_name) {
    sender = `${from.first_name ?? ""} ${from.last_name ?? ""}`.trim();
  } else if (from?.id !== undefined) {
    sender = String(from.id);
  }

  const clippedReplyText =
    replyText.length > 1200 ? `${replyText.slice(0, 1200)}...` : replyText;

  return [
    "[Reply Context]",
    `From: ${sender}`,
    `Message: ${clippedReplyText}`,
    "",
    "[User Message]",
    text,
  ].join("\n");
}

export async function startTelegramBot(
  token: string,
  chatService: ChatService,
  streamEditIntervalMs: number,
  runtimeInfo: RuntimeProviderInfo,
  ownerStorePath: string,
): Promise<() => Promise<void>> {
  const bot = new Telegraf(token);
  const me = await bot.telegram.getMe();
  const botUserId = me.id;
  const ownerStore = new TelegramOwnerStore(ownerStorePath);
  const modelCatalog = new ModelCatalogService(runtimeInfo);

  bot.use(async (ctx, next) => {
    const from = ctx.from;
    if (!from) {
      return;
    }
    if (from.is_bot || from.id === botUserId) {
      return;
    }
    await next();
  });

  const getUserId = (ctx: { from?: { id?: number } }): string | undefined => {
    const id = ctx.from?.id;
    return id === undefined ? undefined : String(id);
  };

  const ensureOwner = async (ctx: {
    from?: { id?: number };
    reply: (message: string) => Promise<unknown>;
  }): Promise<boolean> => {
    const ownerUserId = ownerStore.getOwnerUserId();
    if (!ownerUserId) {
      await ctx.reply(
        "아직 초기화되지 않았습니다. 먼저 /init 을 입력해 소유자를 등록하세요.",
      );
      return false;
    }

    const userId = getUserId(ctx);
    if (userId && userId === ownerUserId) {
      return true;
    }

    await ctx.reply("접근이 거부되었습니다. (이 봇은 /init로 등록한 1명만 사용 가능)");
    return false;
  };

  bot.start(async (ctx) => {
    const ownerUserId = ownerStore.getOwnerUserId();
    const userId = getUserId(ctx);
    if (!ownerUserId) {
      await ctx.reply(
        "OpenShell Telegram 봇입니다.\n\n처음 1회 /init 을 입력해 소유자(1인)를 등록하세요.\n\n" +
          DANGER_WARNING,
      );
      return;
    }

    if (userId && userId === ownerUserId) {
      await ctx.reply(
        "OpenShell Telegram 봇입니다. 메시지를 보내면 답변합니다.\n\n" +
          HELP +
          "\n\n" +
          DANGER_WARNING,
      );
      return;
    }

    await ctx.reply("이 봇은 개인용으로 초기화되어 있습니다.");
  });

  bot.command("help", async (ctx) => {
    const ownerUserId = ownerStore.getOwnerUserId();
    const userId = getUserId(ctx);
    if (!ownerUserId) {
      await ctx.reply(
        "처음 1회 /init 을 입력해 소유자(1인)를 등록하세요.\n\n" + HELP,
      );
      return;
    }

    if (userId && userId === ownerUserId) {
      await ctx.reply(HELP + "\n\n" + DANGER_WARNING);
      return;
    }

    await ctx.reply("이 봇은 개인용으로 초기화되어 있습니다.");
  });

  bot.command("init", async (ctx) => {
    const userId = getUserId(ctx);
    if (!userId) {
      await ctx.reply("UID를 확인할 수 없습니다.");
      return;
    }

    const currentOwner = ownerStore.getOwnerUserId();
    if (!currentOwner) {
      ownerStore.setOwnerUserId(userId);
      await ctx.reply(
        `초기화 완료. 이제 UID ${userId}만 사용할 수 있습니다.\n\n` +
          HELP +
          "\n\n" +
          DANGER_WARNING,
      );
      return;
    }

    if (currentOwner === userId) {
      await ctx.reply(
        `이미 초기화되어 있습니다. (owner UID: ${currentOwner})\n\n` +
          HELP +
          "\n\n" +
          DANGER_WARNING,
      );
      return;
    }

    await ctx.reply("이미 다른 사용자로 초기화되어 있습니다.");
  });

  bot.command("reset", async (ctx) => {
    if (!(await ensureOwner(ctx))) {
      return;
    }
    const chatKey = chatKeyFromContext(ctx);
    chatService.reset(chatKey);
    await ctx.reply("대화 기록을 초기화했습니다.");
  });

  bot.command("uid", async (ctx) => {
    if (!(await ensureOwner(ctx))) {
      return;
    }
    const userId = ctx.from?.id;
    if (!userId) {
      await ctx.reply("UID를 확인할 수 없습니다.");
      return;
    }
    await ctx.reply(`현재 사용자 UID: ${userId}`);
  });

  bot.command("models", async (ctx) => {
    if (!(await ensureOwner(ctx))) {
      return;
    }
    const freshCatalog = new ModelCatalogService(runtimeInfo, 0);
    const chatKey = chatKeyFromContext(ctx);
    const text = buildModelListMessage(
      chatService.getAvailableProviders(),
      chatService.getProvider(chatKey),
      runtimeInfo,
      (provider) => chatService.getModel(chatKey, provider),
      (provider) => chatService.getReasoningEffort(chatKey, provider),
      freshCatalog,
    );
    const chunks = splitTextForPlatform(text, 4096);
    for (const chunk of chunks) {
      await ctx.reply(chunk);
    }
  });

  bot.command("model", async (ctx) => {
    if (!(await ensureOwner(ctx))) {
      return;
    }

    const chatKey = chatKeyFromContext(ctx);
    const args = ctx.message.text.trim().split(/\s+/).slice(1);
    const availableProviders = chatService.getAvailableProviders();
    const currentProvider = chatService.getProvider(chatKey);

    const providerArg = args[0];
    const hasExplicitProvider = providerArg === "codex" || providerArg === "claude";
    if (hasExplicitProvider && args.length === 1) {
      try {
        const changed = chatService.setProvider(chatKey, providerArg);
        await ctx.reply(`provider를 '${changed}'로 변경했습니다.`);
      } catch (error) {
        await ctx.reply(
          error instanceof Error ? error.message : "provider 변경에 실패했습니다.",
        );
      }
      return;
    }

    const targetProvider = hasExplicitProvider
      ? (providerArg as "codex" | "claude")
      : currentProvider;

    if (!availableProviders.includes(targetProvider)) {
      await ctx.reply(`Provider '${targetProvider}' is not configured.`);
      return;
    }

    const valueTokens = hasExplicitProvider ? args.slice(1) : args;
    if (valueTokens.length === 0) {
      const selected = chatService.getModel(chatKey, targetProvider);
      const selectedEffort = chatService.getReasoningEffort(chatKey, targetProvider);
      const fallback = runtimeInfo[targetProvider].model?.trim() || "(CLI 기본값)";
      const usageLines = [
        `provider=${targetProvider}`,
        `현재 채팅 모델=${selected ?? "(override 없음)"}`,
        `기본 모델=${fallback}`,
      ];
      if (targetProvider === "codex") {
        usageLines.push(
          `현재 채팅 effort=${selectedEffort ?? "(override 없음, Codex 기본 effort 사용)"}`,
        );
      }
      usageLines.push("provider 전환: /model codex 또는 /model claude");
      usageLines.push("사용법: /model [codex|claude] <model|default> [effort|default]");
      usageLines.push("예시: /model codex");
      usageLines.push("예시: /model codex gpt-5.3-codex xhigh");
      usageLines.push("예시: /model codex gpt-5.3-codex default");
      usageLines.push("예시: /model claude sonnet");
      await ctx.reply(
        usageLines.join("\n"),
      );
      return;
    }

    if (valueTokens.length > 2) {
      await ctx.reply(
        "사용법: /model [codex|claude] <model|default> [effort|default]\n예시: /model codex gpt-5.3-codex xhigh",
      );
      return;
    }

    const modelArg = valueTokens[0]?.trim();
    const effortArg = valueTokens[1]?.trim();
    if (!modelArg) {
      await ctx.reply(
        "사용법: /model [codex|claude] <model|default> [effort|default]",
      );
      return;
    }

    if (isResetKeyword(modelArg)) {
      if (hasExplicitProvider) {
        try {
          chatService.setProvider(chatKey, targetProvider);
        } catch {
          // Provider validity was already checked.
        }
      }
      chatService.setModel(chatKey, targetProvider, undefined);
      chatService.setReasoningEffort(chatKey, targetProvider, undefined);
      await ctx.reply(
        `provider=${targetProvider} 모델/effort override를 초기화했습니다.`,
      );
      return;
    }

    const catalog = modelCatalog.getCatalog(targetProvider);
    const existsInCatalog = catalog.models.includes(modelArg);

    if (targetProvider === "claude") {
      if (hasExplicitProvider) {
        try {
          chatService.setProvider(chatKey, targetProvider);
        } catch {
          // Provider validity was already checked.
        }
      }
      chatService.setModel(chatKey, targetProvider, modelArg);
      chatService.setReasoningEffort(chatKey, targetProvider, undefined);
      if (effortArg) {
        await ctx.reply(
          existsInCatalog
            ? `provider=claude 모델을 '${modelArg}'로 설정했습니다.\nClaude CLI는 effort 단계를 지원하지 않아 '${effortArg}'는 무시했습니다.`
            : `provider=claude 모델을 '${modelArg}'로 설정했습니다. (목록에는 없음)\nClaude CLI는 effort 단계를 지원하지 않아 '${effortArg}'는 무시했습니다.`,
        );
      } else {
        await ctx.reply(
          existsInCatalog
            ? `provider=claude 모델을 '${modelArg}'로 설정했습니다.`
            : `provider=claude 모델을 '${modelArg}'로 설정했습니다. (목록에는 없음)`,
        );
      }
      return;
    }

    let effortMessage = "";
    if (effortArg) {
      const normalizedEffort = effortArg.toLowerCase();
      if (isResetKeyword(normalizedEffort)) {
        chatService.setReasoningEffort(chatKey, targetProvider, undefined);
        effortMessage = "effort override를 초기화했습니다.";
      } else {
        if (!CODEX_REASONING_EFFORT_SET.has(normalizedEffort)) {
          await ctx.reply(
            `지원하지 않는 effort '${effortArg}' 입니다.\n지원값: ${CODEX_REASONING_EFFORT_LEVELS.join(", ")}`,
          );
          return;
        }

        const supportedEfforts = catalog.reasoningEffortsByModel?.[modelArg];
        if (
          supportedEfforts &&
          supportedEfforts.length > 0 &&
          !supportedEfforts.includes(normalizedEffort)
        ) {
          await ctx.reply(
            `모델 '${modelArg}'의 지원 effort: ${supportedEfforts.join(", ")}`,
          );
          return;
        }

        chatService.setReasoningEffort(chatKey, targetProvider, normalizedEffort);
        effortMessage = `effort='${normalizedEffort}'로 설정했습니다.`;
      }
    }

    if (hasExplicitProvider) {
      try {
        chatService.setProvider(chatKey, targetProvider);
      } catch {
        // Provider validity was already checked.
      }
    }
    chatService.setModel(chatKey, targetProvider, modelArg);
    const currentEffort = chatService.getReasoningEffort(chatKey, targetProvider);
    const modelMessage = existsInCatalog
      ? `provider=${targetProvider} 모델을 '${modelArg}'로 설정했습니다.`
      : `provider=${targetProvider} 모델을 '${modelArg}'로 설정했습니다. (목록에는 없음)`;
    const finalMessageLines = [modelMessage];
    if (effortMessage) {
      finalMessageLines.push(effortMessage);
    }
    finalMessageLines.push(
      `현재 effort=${currentEffort ?? "(override 없음, Codex 기본 effort 사용)"}`,
    );
    await ctx.reply(finalMessageLines.join("\n"));
  });

  bot.on("text", async (ctx) => {
    if (!(await ensureOwner(ctx))) {
      return;
    }

    const text = ctx.message.text.trim();
    if (!text || text.startsWith("/")) {
      return;
    }
    const prompt = buildTelegramPromptWithReplyContext(
      text,
      ctx.message.reply_to_message,
    );

    const chatKey = chatKeyFromContext(ctx);
    const selectedProvider = chatService.getProvider(chatKey);
    const sent = await ctx.reply(`[${selectedProvider}] 생성 중...`);
    const chatId = ctx.chat.id;
    const messageId = sent.message_id;

    const editMessage = async (value: string): Promise<void> => {
      const richText = formatTelegramRichText(value);
      try {
        await ctx.telegram.editMessageText(
          chatId,
          messageId,
          undefined,
          richText,
          { parse_mode: "MarkdownV2" },
        );
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        if (message.includes("message is not modified")) {
          return;
        }
        if (
          message.includes("can't parse entities") ||
          message.includes("message is too long")
        ) {
          await ctx.telegram.editMessageText(chatId, messageId, undefined, value);
          return;
        }
        throw error;
      }
    };

    const editor = createStreamEditController(editMessage, streamEditIntervalMs);
    let hasAssistantText = false;

    try {
      await ctx.sendChatAction("typing");
      const { provider, reply } = await chatService.askStream(chatKey, prompt, {
        onStatus: async (status) => {
          if (hasAssistantText) {
            return;
          }
          editor.queue(
            truncateForPlatform(`[${selectedProvider}] ${status}`, 4096),
          );
        },
        onText: async (partial) => {
          hasAssistantText = partial.trim().length > 0;
          editor.queue(
            truncateForPlatform(`[${selectedProvider}] ${partial}`, 4096),
          );
        },
      });

      await editor.flush(truncateForPlatform(`[${provider}] ${reply}`, 4096));
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "요청 처리 중 오류가 발생했습니다.";
      await editor.flush(truncateForPlatform(`오류: ${message}`, 4096));
    }
  });

  void bot.launch().catch((error: unknown) => {
    console.error("[openshell] Telegram bot launch error:", error);
  });
  console.log(`[openshell] Telegram bot starting as @${me.username}.`);

  return async () => {
    bot.stop("shutdown");
  };
}
