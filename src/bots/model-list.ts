import { existsSync, readFileSync, realpathSync } from "node:fs";
import { join } from "node:path";
import { homedir } from "node:os";
import { spawnSync } from "node:child_process";

import type { ProviderName } from "../types.js";
import { resolveCommand } from "../providers/command-utils.js";

export interface ProviderRuntimeInfo {
  command: string;
  model?: string;
}

export type RuntimeProviderInfo = Record<ProviderName, ProviderRuntimeInfo>;

export interface ProviderModelCatalog {
  provider: ProviderName;
  source: string;
  fetchedAt?: string;
  models: string[];
  reasoningEffortsByModel?: Record<string, string[]>;
  defaultReasoningEffortByModel?: Record<string, string>;
}

export const CODEX_REASONING_EFFORT_LEVELS = [
  "none",
  "minimal",
  "low",
  "medium",
  "high",
  "xhigh",
] as const;

function providerLabel(provider: ProviderName): string {
  return provider === "codex" ? "Codex CLI" : "Claude CLI";
}

function parseCodexModelCache(): ProviderModelCatalog {
  const home = process.env.HOME ?? process.env.USERPROFILE ?? homedir();
  const cachePath = join(home, ".codex", "models_cache.json");
  if (!existsSync(cachePath)) {
    return {
      provider: "codex",
      source: "codex_cache_missing",
      models: [],
    };
  }

  try {
    const raw = JSON.parse(readFileSync(cachePath, "utf8")) as {
      fetched_at?: string;
      models?: Array<{
        slug?: string;
        supported_reasoning_levels?: Array<{ effort?: string }>;
        default_reasoning_level?: string;
      }>;
    };

    const models = [
      ...new Set(
        (raw.models ?? [])
          .map((item) => item.slug)
          .filter((slug): slug is string => Boolean(slug)),
      ),
    ];

    const reasoningEffortsByModel: Record<string, string[]> = {};
    const defaultReasoningEffortByModel: Record<string, string> = {};
    for (const item of raw.models ?? []) {
      const slug = item.slug?.trim();
      if (!slug) {
        continue;
      }

      const efforts = [
        ...new Set(
          (item.supported_reasoning_levels ?? [])
            .map((level) => level.effort?.trim())
            .filter((effort): effort is string => Boolean(effort)),
        ),
      ];
      if (efforts.length > 0) {
        reasoningEffortsByModel[slug] = efforts;
      }

      const defaultEffort = item.default_reasoning_level?.trim();
      if (defaultEffort) {
        defaultReasoningEffortByModel[slug] = defaultEffort;
      }
    }

    return {
      provider: "codex",
      source: "codex_cache",
      fetchedAt: raw.fetched_at,
      models,
      reasoningEffortsByModel,
      defaultReasoningEffortByModel,
    };
  } catch {
    return {
      provider: "codex",
      source: "codex_cache_parse_error",
      models: [],
    };
  }
}

function resolveCommandPath(command: string): string | null {
  const path = resolveCommand(command);
  if (!path) {
    return null;
  }
  try {
    return realpathSync(path);
  } catch {
    return path;
  }
}

function parseClaudeModelsFromBinary(command: string): ProviderModelCatalog {
  if (process.platform === "win32") {
    return {
      provider: "claude",
      source: "claude_binary_scan_unsupported_on_windows",
      models: [],
    };
  }

  const commandPath = resolveCommandPath(command);
  if (!commandPath) {
    return {
      provider: "claude",
      source: "claude_command_missing",
      models: [],
    };
  }

  const escapedPath = commandPath.replaceAll("'", "'\\''");
  const pattern = "claude-(?:haiku|sonnet|opus)-[0-9][0-9A-Za-z.-]*";
  const result = spawnSync(
    "/bin/zsh",
    ["-lc", `strings -a '${escapedPath}' | rg -o '${pattern}' | sort -u`],
    {
      encoding: "utf8",
      maxBuffer: 500_000,
    },
  );

  if (result.status !== 0 && result.status !== 1) {
    return {
      provider: "claude",
      source: "claude_strings_error",
      models: [],
    };
  }

  const fullNames = [...new Set(result.stdout.split("\n").map((line) => line.trim()).filter((line) => line.length > 0))].sort(
    (a, b) => a.localeCompare(b),
  );

  return {
    provider: "claude",
    source: "claude_binary",
    models: fullNames,
  };
}

export class ModelCatalogService {
  private readonly cache = new Map<
    ProviderName,
    { expiresAt: number; value: ProviderModelCatalog }
  >();

  public constructor(
    private readonly runtimeInfo: RuntimeProviderInfo,
    private readonly ttlMs = 5 * 60 * 1000,
  ) {}

  public getCatalog(provider: ProviderName): ProviderModelCatalog {
    const now = Date.now();
    const cached = this.cache.get(provider);
    if (cached && cached.expiresAt > now) {
      return cached.value;
    }

    const value =
      provider === "codex"
        ? parseCodexModelCache()
        : parseClaudeModelsFromBinary(this.runtimeInfo.claude.command);

    this.cache.set(provider, {
      value,
      expiresAt: now + this.ttlMs,
    });
    return value;
  }
}

export function buildModelListMessage(
  availableProviders: ProviderName[],
  currentProvider: ProviderName,
  runtimeInfo: RuntimeProviderInfo,
  getSelectedModel: (provider: ProviderName) => string | undefined,
  getSelectedReasoningEffort: (provider: ProviderName) => string | undefined,
  catalogService: ModelCatalogService,
): string {
  const lines = ["지원하는 모델 목록 (CLI 실제 데이터 기반)"];

  if (availableProviders.length === 0) {
    lines.push("- 사용 가능한 provider가 없습니다.");
  } else {
    for (const provider of availableProviders) {
      const info = runtimeInfo[provider];
      const selectedModel = getSelectedModel(provider);
      const selectedReasoningEffort = getSelectedReasoningEffort(provider);
      const defaultModel = info.model?.trim() || "(CLI 기본값)";
      const catalog = catalogService.getCatalog(provider);

      lines.push("");
      lines.push(`[${providerLabel(provider)} | ${provider}]`);
      lines.push(`command: ${info.command}`);
      lines.push(`기본 모델: ${defaultModel}`);
      lines.push(`현재 채팅 모델: ${selectedModel ?? "(override 없음, 기본 모델 사용)"}`);
      if (provider === "codex") {
        lines.push(
          `현재 채팅 effort: ${selectedReasoningEffort ?? "(override 없음, Codex 기본 effort 사용)"}`,
        );
      }
      lines.push(`목록 출처: ${catalog.source}`);
      if (catalog.fetchedAt) {
        lines.push(`목록 시각: ${catalog.fetchedAt}`);
      }
      if (catalog.models.length === 0) {
        lines.push("모델 목록: 조회 실패");
      } else {
        lines.push(`모델 목록 (${catalog.models.length})`);
        for (const model of catalog.models) {
          const efforts = catalog.reasoningEffortsByModel?.[model];
          const defaultEffort = catalog.defaultReasoningEffortByModel?.[model];
          if (efforts && efforts.length > 0) {
            const effortText = efforts.join(", ");
            const defaultText = defaultEffort ? ` (default: ${defaultEffort})` : "";
            lines.push(`- ${model} | effort: ${effortText}${defaultText}`);
          } else {
            lines.push(`- ${model}`);
          }
        }
      }
    }
  }

  lines.push("");
  lines.push(`현재 provider: ${currentProvider}`);
  lines.push("모델 변경 명령 (provider 생략 시 현재 provider 사용)");
  lines.push("형식: /model [provider] <model|default> [effort|default]");
  lines.push("provider 전환: /model codex 또는 /model claude");
  lines.push(
    `Codex effort 단계: ${CODEX_REASONING_EFFORT_LEVELS.join(", ")}`,
  );
  lines.push(
    "주의: 모델 목록은 로컬 CLI 캐시 기준이며, 계정 권한/플랜에 따라 일부 모델은 실행 시 거부될 수 있습니다.",
  );
  lines.push("Claude CLI는 effort 단계 선택을 지원하지 않습니다.");
  lines.push("");
  lines.push("예시");
  lines.push("- /model codex");
  lines.push("- /model codex gpt-5.3-codex xhigh");
  lines.push("- /model codex gpt-5.3-codex");
  lines.push("- /model codex gpt-5.3-codex default");
  lines.push("- /model codex default");
  lines.push("- /model claude");
  lines.push("- /model claude sonnet");
  return lines.join("\n");
}
